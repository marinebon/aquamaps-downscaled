if (!"librarian" %in% installed.packages())
  install.packages("librarian")

librarian::shelf(
  raquamaps/aquamapsdata, dplyr, here, leaflet, leaflet.extras2, 
  raster, rgee, reticulate, sf)

add_am_raster <- function(
    m, 
    r,
    title,
    cols = c("#FEB24C", "#FD8D3C", "#FC4E2A", "#E31A1C", "#B10026"),
    truncate_to_zero = T){
  # m: leaflet() map
  # r: raster 
  # TODO: migrate to terra::rast()
  
  # r     = r_gebco_bb
  # title = "GEBCO depth (m)"
  # cols  = RColorBrewer::brewer.pal(7, "Blues")
  
  r   <- leaflet::projectRasterForLeaflet(r, method = "bilinear")
  
  # truncate to 0 to prevent negative values 
  #   that were generated by projecting the raster 
  #   from geographic projection (decimal degrees) to Web Mercator (meters)
  if (truncate_to_zero){
    v <- values(r)
    v[v<0] <- 0
    values(r) <- v
  }
  
  pal <- leaflet::colorBin(
    cols, na.omit(unique(values(r))), 
    bins = length(cols), pretty = TRUE, na.color = "#00000000")
  
  e <- raster::extent(r) |> 
    sf::st_bbox() |> 
    st_as_sfc() |> 
    st_as_sf(crs=3857) |> 
    st_transform(4326) |> 
    st_bbox()
  
  m |> 
    leaflet::addRasterImage(
      r, project = F, colors = pal, opacity = 0.8) |> 
    addLegend(
      values = raster::values(r), 
      title = title, pal = pal) |> 
    leaflet::fitBounds(
      lng1 = e[["xmin"]], 
      lat1 = e[["ymin"]], 
      lng2 = e[["xmax"]], 
      lat2 = e[["ymax"]])
}

add_ocean_basemap <- function(m, ...){
  # m: leaflet() map
  
  # browser()
  # print(list(...))
  
  m |>
    # add base: blue bathymetry and light brown/green topography
    addProviderTiles(
      "Esri.OceanBasemap",
      merge_dots_with_list(
        options = providerTileOptions(
          variant = "Ocean/World_Ocean_Base"), 
        l = ...)) |>
    # add reference: placename labels and borders
    addProviderTiles(
      "Esri.OceanBasemap",
      merge_dots_with_list(
        options = providerTileOptions(
          variant = "Ocean/World_Ocean_Reference"), 
        l = ...))
}

calc_im_sp_fine <- function(sp_info){
  
  # apply environmental constraints
  bands_gb <- im_gb$bandNames()$getInfo()
  ims_env <- c()
  im_mask_env <- im_gb$select("Depth")$
    where(im_gb$select("Depth")$gte(0), 1)
  for (b in names(sp_info$env)){ 
    # message(glue::glue("b: {b}"))
    
    im <- im_gb$select(b) # qmap(im)
    # ee_print(im)
    if (b == "PrimProd")
      im <- im$multiply(1000)
    if (all(diff(sp_info$env[[b]]) > 0)){
      im <- im$interpolate(sp_info$env[[b]], c(0,1,1,0), 'clamp')
    } else {
      i_d <- which(diff(sp_info$env[[b]]) > 0)
      i <- min(i_d):(max(i_d)+1)
      # rng <- range(sp_info$env[[b]][i])
      im <- im$
        interpolate(sp_info$env[[b]][i], c(0,1,1,0)[i], 'mask')
      # qmap(im)
      # qmap(im$mask())
    }
    im <- im$
      multiply(100)$
      rename("env")$
      uint8()
    ims_env <- c(ims_env, im)
    
    # update mask
    im_mask_env = im_mask_env$
      where(im$eq(0), 0)$
      where(im$mask()$eq(0), 0)
    # qmap(im_mask_env)
  }
  
  # average environmental interpolations
  im_sp = ee$ImageCollection(ims_env)$
    mean()$
    uint8()$
    rename('sp')
  # qmap(im_sp)
  
  # fao mask
  fc_fao_sp = fc_fao$filter(ee$Filter$inList('zone', sp_info[['FAOAreas']]))
  im_fao_mask = ee$ImageCollection(c(
    ee$Image$constant(0)$toInt(),
    ee$Image$constant(1)$toInt()$clipToCollection(fc_fao_sp) ))$mosaic()
  # qmap(im_fao_mask)
  
  # apply env + fao mask
  im_mask <- im_mask_env$
    where(im_fao_mask$eq(0), 0)
  # qmap(im_mask_env)
  # qmap(im_mask)
  im_sp <- im_sp$
    mask(im_mask)
  # qmap(im_sp)
  
  im_sp
}

calc_im_sp_coarse <- function(sp_info){

  # apply environmental constraints
  bands_am <- im_am$bandNames()$getInfo()
  ims_env <- c()
  im_mask_env <- im_am$select("Depth")$
    where(im_am$select("Depth")$gte(0), 1)
  for (b in names(sp_info$env)){ 
    # message(glue::glue("b: {b}"))
    
    im <- im_am$select(b) # qmap(im)
    # ee_print(im)
    # if (b == "PrimProd")
    #   im <- im$multiply(1000)
    if (all(diff(sp_info$env[[b]]) > 0)){
      im <- im$interpolate(sp_info$env[[b]], c(0,1,1,0), 'clamp')
    } else {
      i_d <- which(diff(sp_info$env[[b]]) > 0)
      i <- min(i_d):(max(i_d)+1)
      # rng <- range(sp_info$env[[b]][i])
      im <- im$
        interpolate(sp_info$env[[b]][i], c(0,1,1,0)[i], 'mask')
      # qmap(im)
      # qmap(im$mask())
    }
    im <- im$
      multiply(100)$
      rename("env")$
      uint8()
    ims_env <- c(ims_env, im)

    # update mask
    im_mask_env = im_mask_env$
      where(im$eq(0), 0)$
      where(im$mask()$eq(0), 0)
  }
  # qmap(im)
  # qmap(im_mask_env)
  
  # average environmental interpolations
  im_sp = ee$ImageCollection(ims_env)$
    mean()$
    uint8()$
    rename('sp')
  # qmap(im_sp)

  # create mask for FAO areas
  im_fao <- im_am$select("FAOArea")
  im_mask_fao <- im_fao$
    where(im_fao$neq(0), 0)
  # qmap(im_fao_mask)
  for (a in sp_info[["FAOAreas"]]){ 
    # a = sp_info[["FAOAreas"]][1]
    # message(glue::glue("FAOArea: {a}"))
    im_mask_fao = im_mask_fao$
      where(im_fao$eq(a), 1)
    # qmap(im_fao_mask)
  }
  #qmap(im_fao_mask)
  
  # apply mask
  # qmap(im_sp)
  # qmap(im_mask_env)
  # qmap(im_mask_fao)
  im_mask <- im_mask_env$
    where(im_mask_fao$eq(0), 0)
  # qmap(im_mask)
  im_sp <- im_sp$
    mask(im_mask)
  # qmap(im_sp)
  
  im_sp
}

get_am_spp <- function(){
  am_spp <- tbl(am_db, "speciesoccursum_r") |> 
    select(
      SpeciesID, SpecCode, Genus, Species) |> 
    distinct() |> 
    collect() |> 
    mutate(
      sp_sci = glue("{Genus} {Species}")) |> 
    arrange(sp_sci)
  # nrow(am_spp)                             # 23,699
  # am_spp$Kingdom |> unique() |> length()   #      5
  # am_spp$Phylum  |> unique() |> length()   #     34
  # am_spp$Class   |> unique() |> length()   #     70
  # am_spp$Order   |> unique() |> length()   #    298
}

get_sp_info <- function(sp_key){
  # sp_key matches hspen_r.Speccode if numeric, otherwise
  #                hspen_r.SpeciesID
  
  # TODO:
  # - look at speciesoccursum_r.StockDefs multiple stock definitions / lifestage per sp?
  #   tbl(am_db, "speciesoccursum_r")
  
  sp_key_is_numeric <- !grepl("\\D", sp_key)
  if (sp_key_is_numeric)
    sp_key <- as.numeric(sp_key)
  
  if (is.numeric(sp_key)){
    d_hspen <- tbl(am_db, "hspen_r") |> 
      filter(Speccode == !!sp_key) |>
      collect() |> 
      # TODO: filter by sp_id vs sp_code
      #   eg sp_code == 46802: 
      #     "sp_scientific": ["Ammodytoides gilli", "Isopora palifera"]
      #     "sp_id"        : ["Fis-138579"        , "W-Scl-730686"]
      slice(1)
  } else {
    d_hspen <- tbl(am_db, "hspen_r") |> 
      filter(SpeciesID == !!sp_key) |>
      collect() |> 
      slice(1)
  }
  
  # browser()
  
  message(glue("sp_key: {sp_key}"))
  
  vars_yes <- d_hspen |> 
    select(ends_with("YN")) |> 
    pivot_longer(
      everything()) |> 
    filter(value == 1) |> 
    pull(name) |> 
    str_replace("YN","")
  
  d_probs <- tribble(
    ~prob_name, ~prob_value,
    "Min"      , 0,
    "PrefMin"  , 1,
    "PrefMax"  , 1,
    "Max"      , 0)
  
  # browser()
  d_env <- d_hspen |> 
    select(starts_with(vars_yes)) |>
    select(!ends_with("YN")) |> 
    pivot_longer(
      everything(),
      values_to = "var_value") |> 
    separate_wider_regex(
      name,
      c(var       = paste(vars_yes, collapse = "|"), # "",
        prob_name = paste(d_probs$prob_name, collapse = "|"))) |> 
    left_join(
      d_probs,
      by = "prob_name")
  
  l_env <- d_env |> 
    group_by(var) |> 
    summarise(
      vec = list(var_value)) |> 
    deframe()
  
  sp_info <- list()
  
  d_sp <- tbl(am_db, "speciesoccursum_r") |> 
    filter(SpeciesID == !!d_hspen$SpeciesID) |> 
    collect() |> 
    mutate(
      sp_sci = glue("{Genus} {Species}"))
  sp_info["sp_scientific"] <- list(d_sp$sp_sci)
  sp_info["sp_code"]       <- list(d_sp$SpecCode)
  sp_info["sp_id"]         <- list(d_sp$SpeciesID)
  
  sp_info["FAOAreas"] <- d_hspen$FAOAreas |> 
    str_split(", ") %>%
    .[[1]] |> 
    as.integer() |> 
    list()
  
  sp_info["env"] <- list(l_env)
  
  # browser()
  d_sp <- tbl(am_db, "speciesoccursum_r") |> 
    filter(SpecCode == !!sp_info[["sp_code"]]) |>
    # filter(SpecCode == 69007) |> 
    collect()
  
  sp_info$taxa <- d_sp |> 
      select(Kingdom, Phylum, Class, Order, Family) |> 
      pivot_longer(everything()) |> 
      deframe() |> 
      as.list()
  
  sp_info$attr <- d_sp |> 
    select(
      deepwater, angling, diving, dangerous, m_invertebrates, 
      highseas, invasive, resilience) |> 
    mutate(across(everything(), as.character)) |> 
    pivot_longer(everything()) |> 
    deframe() |> 
    as.list()
  
  sp_info$iucn <- d_sp |> 
    select(
      iucn_id, iucn_code, iucn_version, provider) |> 
    mutate(across(everything(), as.character)) |> 
    pivot_longer(everything()) |> 
    deframe() |> 
    as.list()
  
  # deepwater,        # Does the species occur in the deep-sea (i.e. tagged bathypelagic or bathydemersal in FishBase or SeaLifeBase)? 0=No, 1=Yes
  # angling,          # Is the species a sport fish (i.e. tagged as a GameFish in FishBase)? 0=No, 1=Yes
  # diving,           # Is the species found on a dive (i.e. where DepthPrefMin in HSPEN < 20 meters)? 0=No, 1=Yes
  # dangerous,        # Is the species dangerous (i.e. tagged as ‘traumatogenic or venonous’ in FishBase or SeaLifeBase)? 0=No, 1=Yes
  # m_invertebrates,  # Is the species a marine invertebrate? 0=No, 1=Yes
  # highseas,         # Is the species an open ocean fish species (i.e. tagged as pelagic-oceanic in FishBase)? 0=No, 1=Yes
  # invasive,         # Is the species recorded to be invasive (i.e. in FishBase or SeaLifeBase)? 0=No, 1=Yes
  # resilience,       # Resilience of the species (i.e. as recorded in FishBase/SeaLifeBase) [varchar]
  # iucn_id,          # IUCN species identifier	[int]
  # iucn_code,        # IUCN Red list classification assigned to the species [varchar]
  # iucn_version,     # IUCN version [varchar]
  # provider) |>      # FishBase (FB) or SeaLifeBase (SLB)? [varchar]
  
  sp_info
}


rename_bands_bio_oracle <- function(){
  # TODO!
  
  librarian::shelf(geojsonio)
  
  ee_print(im_bo)
  
  r <- terra::rast(tif)
  names(r)
  
  cat(names(r))
  im_am <- im_am$rename(names(r))
  
  task_im <- ee_image_to_asset(
    im_am,
    description = "ExportHcafBandsRenamed",
    assetId     = "projects/eq-am-fine/assets/sdmpredictors/am-hcaf_v1-simple",
    overwrite   = T,
    pyramidingPolicy = list(
      hcaf_id  = "mode",
      ctr_lon  = "mean",
      ctr_lat  = "mean",
      FAOArea  = "mode",
      Depth    = "mean",
      Temp     = "mean",
      Salinity = "mean",
      PrimProd = "mean",
      IceCon   = "mean")
    # dimensions = NULL,
    # region = NULL,
    # scale = NULL,
    # crs = NULL,
    # crsTransform = NULL,
    # maxPixels = NULL
  )
  task_im$start()
}

qmap <- function(
    im, rng = NULL, palette = c('011de2', 'afafaf', '3603ff', 'fff477', 'b42109'), ...){
  
  if (is.null(rng)){
    rng = im$reduceRegion(
      reducer    = ee$Reducer$minMax(),	
      geometry   = ply_globe, # $getInfo(),
      bestEffort = T)$
      getInfo() |> 
      as.numeric() |> 
      sort()
    message(glue::glue("qmap im rng: [{paste(rng, collapse=', ')}]"))
  }
  
  Map$addLayer(
    im, 
    list(
      min = rng[1], max = rng[2],
      palette = palette),
    ...)
}