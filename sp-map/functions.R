if (!"librarian" %in% installed.packages())
  install.packages("librarian")

librarian::shelf(
  raquamaps/aquamapsdata, dplyr, here, leaflet, leaflet.extras2, 
  raster, rgee, reticulate, sf)

add_am_raster <- function(
    m, 
    r,
    title,
    cols = c("#FEB24C", "#FD8D3C", "#FC4E2A", "#E31A1C", "#B10026"),
    truncate_to_zero = T){
  # m: leaflet() map
  # r: raster 
  # TODO: migrate to terra::rast()
  
  # r     = r_gebco_bb
  # title = "GEBCO depth (m)"
  # cols  = RColorBrewer::brewer.pal(7, "Blues")
  
  r   <- leaflet::projectRasterForLeaflet(r, method = "bilinear")
  
  # truncate to 0 to prevent negative values 
  #   that were generated by projecting the raster 
  #   from geographic projection (decimal degrees) to Web Mercator (meters)
  if (truncate_to_zero){
    v <- values(r)
    v[v<0] <- 0
    values(r) <- v
  }
  
  pal <- leaflet::colorBin(
    cols, na.omit(unique(values(r))), 
    bins = length(cols), pretty = TRUE, na.color = "#00000000")
  
  e <- raster::extent(r) |> 
    sf::st_bbox() |> 
    st_as_sfc() |> 
    st_as_sf(crs=3857) |> 
    st_transform(4326) |> 
    st_bbox()
  
  m |> 
    leaflet::addRasterImage(
      r, project = F, colors = pal, opacity = 0.8) |> 
    addLegend(
      values = raster::values(r), 
      title = title, pal = pal) |> 
    leaflet::fitBounds(
      lng1 = e[["xmin"]], 
      lat1 = e[["ymin"]], 
      lng2 = e[["xmax"]], 
      lat2 = e[["ymax"]])
}

add_ocean_basemap <- function(m, ...){
  # m: leaflet() map
  
  # browser()
  # print(list(...))
  
  m |>
    # add base: blue bathymetry and light brown/green topography
    addProviderTiles(
      "Esri.OceanBasemap",
      merge_dots_with_list(
        options = providerTileOptions(
          variant = "Ocean/World_Ocean_Base"), 
        l = ...)) |>
    # add reference: placename labels and borders
    addProviderTiles(
      "Esri.OceanBasemap",
      merge_dots_with_list(
        options = providerTileOptions(
          variant = "Ocean/World_Ocean_Reference"), 
        l = ...))
}

calc_im_sp_fine <- function(sp_env){
  
  # apply environmental constraints
  im_depth_iy    = im_depth$
    interpolate(sp_env[['Depth']], c(0,1,1,0), 'clamp')$
    multiply(100)$
    rename("depth")$
    uint8()
  
  im_temp_iy     = im_bo$select('b1')$
    interpolate(sp_env[['Temp']], c(0,1,1,0), 'clamp')$
    multiply(100)$
    rename("temp")$
    uint8()
  
  im_salinity_iy = im_bo$select('b2')$
    interpolate(sp_env[['Salinity']], c(0,1,1,0), 'clamp')$
    multiply(100)$
    rename("salinity")$
    uint8()
  
  im_primprod_iy = im_bo$select('b3')$
    multiply(1000)$
    interpolate(sp_env[['PrimProd']], c(0,1,1,0), 'clamp')$
    multiply(100)$
    rename("primprod")$
    uint8()
  
  im_icecon_iy   = im_bo$select('b4')$
    interpolate(sp_env[['IceCon']], c(0,1,1,0), 'clamp')$
    multiply(100)$
    rename("icecon")$
    uint8()
  
  im_sp = ee$ImageCollection(c(
    im_depth_iy$rename('env'), 
    im_icecon_iy$rename('env'),
    im_primprod_iy$rename('env'),
    im_salinity_iy$rename('env'),
    im_temp_iy$rename('env') ))$
    mean()$
    uint8()$
    rename('sp')
  
  # fao mask
  fc_fao_sp = fc_fao$filter(ee$Filter$inList('zone', sp_env[['FAOAreas']]))
  im_fao_mask = ee$ImageCollection(c(
    ee$Image$constant(0)$toInt(),
    ee$Image$constant(1)$toInt()$clipToCollection(fc_fao_sp) ))$mosaic()
  
  # apply env + fao mask
  im_mask = im_depth_iy$
    where(im_icecon_iy$eq(0), 0)$
    where(im_primprod_iy$eq(0), 0)$
    where(im_salinity_iy$eq(0), 0)$
    where(im_temp_iy$eq(0), 0)$
    where(im_fao_mask$eq(0), 0)$
    where(im_sp$lt(10), 0)
  im_sp   = im_sp$mask(im_mask)
  
  im_sp
}

calc_im_sp_coarse <- function(sp_env){

  # apply environmental constraints
  bands_am <- im_am$bandNames()$getInfo()
  ims_env <- c()
  im_depth <- im_am$select("Depth")
  im_mask_env <- im_depth$
    where(im_depth$neq(0), 1)
  for (b in intersect(names(sp_env), bands_am)){ 
    # b = intersect(names(sp_env), bands_am)[1]
    # message(glue::glue("b: {b}"))
    
    im <- im_am$select(b)
    # if (b == "PrimProd")
    #   im <- im$multiply(1000)
    im <- im$
      interpolate(sp_env[[b]], c(0,1,1,0), 'clamp')$
      multiply(100)$
      rename("env")$
      uint8()
    ims_env <- c(ims_env, im)

    # update mask
    im_mask_env = im_mask_env$
      where(im$eq(0), 0)
  }
  # qmap(im)
  # qmap(im_mask_env)
  
  # average environmental interpolations
  im_sp = ee$ImageCollection(ims_env)$
    mean()$
    uint8()$
    rename('sp')
  # qmap(im_sp)

  # create mask for FAO areas
  im_fao <- im_am$select("FAOArea")
  im_mask_fao <- im_fao$
    where(im_fao$neq(0), 0)
  # qmap(im_fao_mask)
  for (a in sp_env[["FAOAreas"]]){ 
    # a = sp_env[["FAOAreas"]][1]
    # message(glue::glue("FAOArea: {a}"))
    im_mask_fao = im_mask_fao$
      where(im_fao$eq(a), 1)
    # qmap(im_fao_mask)
  }
  #qmap(im_fao_mask)
  
  # apply mask
  # qmap(im_sp)
  # qmap(im_mask_env)
  # qmap(im_mask_fao)
  im_mask <- im_mask_env$
    where(im_mask_fao$eq(0), 0)
  # qmap(im_mask)
  im_sp <- im_sp$
    mask(im_mask)
  # qmap(im_sp)
  
  im_sp
}

rename_bands_bio_oracle <- function(){
  # TODO!
  
  librarian::shelf(geojsonio)
  
  ee_print(im_bo)
  
  r <- terra::rast(tif)
  names(r)
  
  cat(names(r))
  im_am <- im_am$rename(names(r))
  
  task_im <- ee_image_to_asset(
    im_am,
    description = "ExportHcafBandsRenamed",
    assetId     = "projects/eq-am-fine/assets/sdmpredictors/am-hcaf_v1-simple",
    overwrite   = T,
    pyramidingPolicy = list(
      hcaf_id  = "mode",
      ctr_lon  = "mean",
      ctr_lat  = "mean",
      FAOArea  = "mode",
      Depth    = "mean",
      Temp     = "mean",
      Salinity = "mean",
      PrimProd = "mean",
      IceCon   = "mean")
    # dimensions = NULL,
    # region = NULL,
    # scale = NULL,
    # crs = NULL,
    # crsTransform = NULL,
    # maxPixels = NULL
  )
  task_im$start()
}

qmap <- function(im, rng = NULL, ...){
  
  if (is.null(rng)){
    rng = im$reduceRegion(
      reducer    = ee$Reducer$minMax(),	
      geometry   = ply_globe, # $getInfo(),
      bestEffort = T)$
      getInfo() |> 
      as.numeric() |> 
      sort()
    message(glue::glue("qmap im rng: [{paste(rng, collapse=', ')}]"))
  }
  
  Map$addLayer(
    im, 
    list(
      min = rng[1], max = rng[2],
      palette = c('011de2', 'afafaf', '3603ff', 'fff477', 'b42109')),
    ...)
}