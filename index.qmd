---
title: "Downscaling AquaMaps"
subtitle: "v01: blue whale, GEBCO SoCal"
author: "Benjamin D. Best <ben@ecoquants.com>"
date: now
date-format: "YYYY-MM-DD HH:mm (z)"
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    code-fold: true
    code-tools: true
  docx:
    toc: true
    toc-depth: 3
    number-sections: true
    code-fold: true
bibliography: "mbon-bio-idx.bib"
editor_options: 
  chunk_output_type: console
---

## Overview

**Goal**: Downscale [AquaMaps.org](https://aquamaps.org) species distributions [@kaschnerAquaMapsPredictedRange2023;@readyPredictingDistributionsMarine2010] from 0.5 decimal degrees to 15 arc seconds (111.11 km to `r (111.11 / 60 / 60 * 15) |> round(2)` km at the equator), using  the R package [`aquamapsdata`](https://raquamaps.github.io/aquamapsdata/index.html) and the the General Bathymetric Chart of the Oceans [GEBCO](https://www.gebco.net/).

We start with the "Blue Whale" ([_Balaenoptera musculus_](https://aquamaps.org/preMap2.php?cache=1&SpecID=ITS-Mam-180528)) and Southern California. 

Later we'll iterate over species and expand to global, which will require large raster handling techniques using Cloud-Optimized GeoTIFFS (COGs; see [cogeo.org](https://www.cogeo.org)).

All code and files (except the large global GEBCO grid) are found in this repository:

- [github.com/marinebon/aquamaps-downscaled](https://github.com/marinebon/aquamaps-downscaled)


```{r qmd_setup, include=FALSE}
knitr::opts_chunk$set(
  echo    = T,
  message = F,
  warning = F)

if (!knitr::is_html_output())
  knitr::opts_chunk$set(
    echo = F)
```

```{r}
#| label: setup

# packages ----
if (!"librarian" %in% installed.packages())
  install.packages("librarian")
if (!"rcrypt" %in% installed.packages())
  devtools::install_bitbucket("bklamer/rcrypt") # dependency for aquamapsdata
librarian::shelf(
 bklamer/rcrypt,
 raquamaps/aquamapsdata,
 dplyr, ggplot2, glue, here, knitr, leaflet, 
 # TODO: migrate raster to terra
 # terra, 
 raster, rnaturalearth, sf, stringr, tidyr,
 quiet = T)
select = dplyr::select

# initial run-once step required to install remote db locally
# download_db(force = TRUE)

# aquamaps database ----
am_db <- default_db("sqlite")

# paths ----
dir_big         <- "/Users/bbest/big"
gebco_nc        <- glue("{dir_big}/gebco_2022_sub_ice_topo/GEBCO_2022_sub_ice_topo.nc")
gebco_socal_tif <- here("data/gebco_socal.tif")
land_socal_geo  <- here("data/land_socal.geojson")

# custom functions ----
add_ocean_basemap <- function(m){
  # m: leaflet() map
  
  m |>
    # add base: blue bathymetry and light brown/green topography
    addProviderTiles(
      "Esri.OceanBasemap",
      options = providerTileOptions(
        variant = "Ocean/World_Ocean_Base")) |>
    # add reference: placename labels and borders
    addProviderTiles(
      "Esri.OceanBasemap",
      options = providerTileOptions(
        variant = "Ocean/World_Ocean_Reference"))
}

add_am_raster <- function(
    m, 
    r,
    title,
    cols = c("#FEB24C", "#FD8D3C", "#FC4E2A", "#E31A1C", "#B10026"),
    truncate_to_zero = T){
  # m: leaflet() map
  # r: raster 
  # TODO: migrate to terra::rast()
  
  # r     = r_gebco_bb
  # title = "GEBCO depth (m)"
  # cols  = RColorBrewer::brewer.pal(7, "Blues")
  
  r   <- leaflet::projectRasterForLeaflet(r, method = "bilinear")
  
  # truncate to 0 to prevent negative values 
  #   that were generated by projecting the raster 
  #   from geographic projection (decimal degrees) to Web Mercator (meters)
  if (truncate_to_zero){
    v <- values(r)
    v[v<0] <- 0
    values(r) <- v
  }
  
  pal <- leaflet::colorBin(
    cols, na.omit(unique(values(r))), 
    bins = length(cols), pretty = TRUE, na.color = "#00000000")
  
  e <- raster::extent(r) |> 
    sf::st_bbox() |> 
    st_as_sfc() |> 
    st_as_sf(crs=3857) |> 
    st_transform(4326) |> 
    st_bbox()
    
  m |> 
    leaflet::addRasterImage(
      r, project = F, colors = pal, opacity = 0.8) |> 
    addLegend(
      values = raster::values(r), 
      title = title, pal = pal) |> 
    leaflet::fitBounds(
      lng1 = e[["xmin"]], 
      lat1 = e[["ymin"]], 
      lng2 = e[["xmax"]], 
      lat2 = e[["ymax"]])
}
```

## Species map (blue whale)

```{r}
#| label: fig-blue_whale_map
#| fig-cap: Map of blue whale (_Balaenoptera musculus_) distribution from AquaMaps.

# fuzzy search allows full text search operators AND, OR, NOT and +
# see https://www.sqlitetutorial.net/sqlite-full-text-search/
sp_term <- "blue whale"
key <- am_search_fuzzy(search_term = sp_term) |> 
  pull(key) # "ITS-Mam-180528"

# get the identifier for the species
r <- am_raster(key)

# show the native habitat map
m <- leaflet() |> 
  add_ocean_basemap() |> 
  add_am_raster(r, title = sp_term)
m 
```

### Zoom to SoCal

Notice the very large pixels, far bigger than useful for smaller planning purposes, such as for Sanctuaries or BOEM Wind Energy Areas.

```{r}
#| label: fig-blue_whale_map_socal
#| fig-cap: Map of blue whale (_Balaenoptera musculus_) distribution from AquaMaps zoomed into Southern California. Notice the very large pixels, far bigger than useful for smaller planning purposes, such as for Sanctuaries or BOEM Wind Energy Areas.

# Southern California
bbox <- c(-121, 32, -117, 35)
m |>
  fitBounds(lng1 = bbox[1], lat1 = bbox[2], lng2 = bbox[3], lat2 = bbox[4])
```


## Environmental preferences

Here are the environmental preferences for the species in the database.

```{r}
#| label: tbl-blue_whale_env
#| tbl-cap: Table of blue whale (_Balaenoptera musculus_) environmental suitability parameters from Aquamaps.

sp_env <- am_hspen() |> 
  filter(SpeciesID == key) |> 
  head(1) |> 
  collect()

sp_env |> 
  mutate(across(everything(), as.character)) |> 
  pivot_longer(everything()) |> 
  kable()
```

Now let's convert all variables having `{Var}YN == 1` into the relative environmental suitability rhomboids [@kaschnerMappingWorldwideDistributions2006].

```{r}
#| label: tbl-blue_whale_env_yes
#| tbl-cap: Table environmental suitability parameters from Aquamaps that are applicable to blue whale (_Balaenoptera musculus_), i.e. `{Var}YN == 1` in @tbl-blue_whale_env.

var <- "Depth"

d_probs <- tribble(
  ~prob_name, ~prob_value,
  "Min"      , 0,
  "PrefMin"  , 1,
  "PrefMax"  , 1,
  "Max"      , 0)

vars_yes <- sp_env |> 
  select(ends_with("YN")) |> 
  pivot_longer(
    everything()) |> 
  filter(value == 1) |> 
  pull(name) |> 
  str_replace("YN","")

d <- sp_env |> 
  select(starts_with(vars_yes)) |>
  select(!ends_with("YN")) |> 
  pivot_longer(
    everything(),
    values_to = "var_value") |> 
  separate_wider_regex(
    name,
    c(var       = paste(vars_yes, collapse = "|"), # "",
      prob_name = paste(d_probs$prob_name, collapse = "|"))) |> 
  left_join(
    d_probs,
    by = "prob_name")

kable(d)
```

```{r}
#| label: fig-blue_whale_env_yes
#| fig-cap: Plots of environmental suitability parameters from Aquamaps that are applicable to blue whale (_Balaenoptera musculus_) from @tbl-blue_whale_env_yes.

g <- ggplot(d, aes(var_value, prob_value)) +
  geom_area() +
  theme_light() +
  facet_wrap(
    vars(var), 
    scales = "free") +
  labs(
    title    = sp_term,
    subtitle = "environmental envelope",
    x        = NULL,
    y        = "probability of presence")
g
```


## Depth (GEBCO) for SoCal


```{r}
#| label: fig-depth_socal
#| fig-cap: Map of depth from GEBCO zoomed into Southern California. Notice the much higher resolution compared to @fig-blue_whale_map_socal.

# limit to bounding box for now
ply_bb <- extent(
  c(bbox[1], bbox[3], bbox[2], bbox[4])) |> 
  st_bbox() |> 
  st_as_sfc() |> 
  st_as_sf(crs = 4326)

# land
if (!file.exists(land_socal_geo)){
  ply_land <- ne_download(
    scale       = 10, # 110/50/10: high spatial resolution (10 m)
    type        = "land", 
    category    = "physical",
    returnclass = "sf")
  # plot(ply_land)
  ply_land_bb <- ply_land |> 
    st_intersection(ply_bb)
  # plot(ply_land_bb)
  write_sf(ply_land_bb, land_socal_geo)
}
ply_land_bb <- read_sf(land_socal_geo)
# plot(ply_land_bb)

if (!file.exists(gebco_socal_tif)){
  # read large GEBCO netcdf file outside repo
  r_gebco <- raster(gebco_nc)
  
  # crop to SoCal bounding box
  r_gebco_bb <- r_gebco |> 
    crop(ply_bb)
  
  # mask out land, ie > 0 
  r_gebco_bb <- r_gebco_bb |> 
    mask(r_gebco_bb <= 0, maskvalue = 0) * -1
  
  # write to TIF
  writeRaster(r_gebco_bb, gebco_socal_tif, overwrite = T)
}
r_gebco_bb <- raster(gebco_socal_tif)

m <- leaflet() |> 
  add_ocean_basemap() |> 
  add_am_raster(
    r                = r_gebco_bb, 
    title            = "GEBCO depth (m)", 
    cols             = RColorBrewer::brewer.pal(7, "Blues"))
m 
```

## Ramp depth with species preference


### Create `ramp_env()` function

```{r}
#| label: fig-ramp_env
#| fig-cap: Plot of original depth preferences for 4 points (black circles) and interpolated values (red asterisks) using new `ramp_env()` function.

ramp_env <- function(v, min, min_pref, max, max_pref){
  
  x <- c(min, min_pref, max, max_pref)
  y <- c(  0,        1,   1,        0)

  approx(
    x, y, 
    xout   = v, 
    yleft  = 0,
    yright = 0,
    rule   = 2,
    method = "linear")$y
}

p <- d |> 
  filter(var == !!var)
p <- setNames(p$var_value, p$prob_name) |> as.list()
# p
#   Min PrefMin PrefMax     Max 
#     0    1000    4000    8000

x_pref <- c(p$Min, p$PrefMin, p$PrefMax, p$Max)
y_pref <- c(  0,        1,   1,        0)
x_new <- seq(-200, 10000, by=100)
y_new <- ramp_env(x_new, p$Min, p$PrefMin, p$PrefMax, p$Max)

plot(
  x_pref,
  y_pref, 
  xlim = range(c(x_pref, x_new), na.rm=T), 
  ylim = range(c(y_pref, y_new), na.rm=T),
  xlab = var,
  ylab = sp_term)
points(x_new, y_new, col = 2, pch = "*")
```

### Apply to SoCal

Apply the `ramp_env()` function to the SoCal depth using `r {sp_term}` preferences.

```{r}
#| label: fig-map_sp_depth_bb
#| fig-cap: Map of depth preference for `r sp_term` applied to SoCal depth with the `ramp_env()` function.

r_sp_depth_bb <- terra::app(
  x        = terra::rast(r_gebco_bb), 
  fun      = ramp_env, 
  min      = p$Min, 
  min_pref = p$PrefMin, 
  max_pref = p$PrefMax,
  max      = p$Max) |> 
  raster()

m <- leaflet() |> 
  add_ocean_basemap() |> 
  add_am_raster(
    r                = r_sp_depth_bb, 
    title            = glue("{sp_term}, {var} only"))
m 
```

## Next Steps

Goal: Downscale global AquaMaps with all env preferences

TODO: 

- [ ] Gather finer resolution global data based on yes/no parameters (`*YN`):

```{r}
#| label: cklist_vars
#| echo: false
#| output: asis

vars_yn <- sp_env |> 
  select(ends_with("YN")) |> 
  names() |> 
  str_replace("YN", "")
# vars_yn <- c("Depth", "Temp", "Salinity")

vars_done <- list(
  Depth = "[GEBCO](https://www.gebco.net)")
vars_todo <- list()

txt_cks  <- ifelse(vars_yn %in% names(vars_done), 'x', ' ')
txt_info <- ifelse(
  vars_yn %in% names(vars_done), 
  vars_done[vars_yn], 
  ifelse(
    vars_yn %in% names(vars_todo), 
    vars_todo[vars_yn], 
    ""))
glue("    - [{txt_cks}] {vars_yn}: {txt_info}", .trim = F)
```
- [ ] Work out rest of individual species workflow
    - [ ] Apply `ramp_env()` to each environmental parameter applicable to the species (ie `{var}YN ==1`)
    - [ ] Average all environmental parameter grids for the species
    - [ ] Clip to `NMostLat`, `SMostLat`, `WMostLong`, `EMostLong`
    - [ ] Mask to `FAOAreas`
    - [ ] Figure out unknown fields: `ExtnRuleYN`, `MapOpt`, ...
- [ ] Repeat for workflow for ALL species
- [ ] Render maps from anywhere
    - [ ] Store in COG with each species as a separate layer; or try individual layer COGs
    - [ ] Upload COG to Google Cloud Storage
    - [ ] Install [TiTiler](https://developmentseed.org/titiler) on MarineBON.app server
    - [ ] Render map layers from COG using TiTiler in new function(s) borrowing from [`offhabr`](https://offshorewindhabitat.info/offhabr/index.html) functions like [`oh_map_cog_lyr()`](https://offshorewindhabitat.info/offhabr/reference/oh_map_cog_lyr.html)
- [ ] Build Shiny app
    - [ ] Render map of selected species from dropdown
    - [ ] Summarize species from drawn area
    - [ ] Summarize species from selected area from existing: 
        - [ ] EEZ
        - [ ] LME
        - [ ] Sanctuary
        - [ ] BOEM Wind Energy Area
        - [ ] ...
- [ ] Calculate biodiversity metrics
    - [ ] Richness
    - [ ] Abundance
    - [ ] Extinction Risk
    - [ ] Endemism
    - [ ] Foundation Species
    - [ ] ...

## References
